const { Sequelize } = require("sequelize");
const CarModel = require("../../../car/model/carModel");
const ReserveModel = require("../../model/reserveModel");
const UserModel = require("../../../user/model/userModel");
const ReserveRepository = require("../reserveRepository");
const ReserveNotFoundError = require("../error/reserveNotFoundError");
const ReserveIdNotDefinedError = require("../error/reserveIdNotDefinedError");

const sequelizeInstance = new Sequelize("sqlite::memory", {
	logging: false
});
let repository;

const sampleReserve = {
	car: {
		id: 1
	},
	user: {
		id: 1
	},
	since: "1999-01-01",
	until: "1999-01-03",
	pricePerDay: 10,
	totalPrice: 30,
	payed: false,
	paymentMethod: "Cash"
};

beforeAll(async () => {
	const reserveModel = ReserveModel.setup(sequelizeInstance);
	const carModel = CarModel.setup(sequelizeInstance);
	const userModel = UserModel.setup(sequelizeInstance);

	reserveModel.setUpAssociations(carModel, userModel);

	repository = new ReserveRepository(reserveModel, carModel, userModel);

});

beforeEach(async () => {
	// eslint-disable-next-line no-useless-catch
	try{
		await sequelizeInstance.sync({ force: true });
		await CarModel.create({
			brand: "chevrolet",
			model: "onix",
			car_year: 2020,
			transmission: "Automatic",
			seats: "4",
			doors: "5",
			air_conditioning: 1,
			trunk: 500,
			fuel: "Hybrid",
			price: 30,
			unlimited_mileage: 1,
			car_image: "image",
			car_description: "car description"
		}, {
			isNewRecord: true
		});
		await UserModel.create({
			names: "user",
			surnames: "user surnames",
			personal_id_type: "Passport",
			personal_id_number: "12345678",
			nationality: "Argentinean",
			email: "user@email.com",
			phone: "+12 3456-7890",
			birthdate: "2000-01-01",
			address: "User address"
		},{
			isNewRecord: true
		});
	}catch(e){
		throw e;
	}
});


describe("getAll method", () => {
	test("returns an array with reserves", async () => {
		const NEW_AUTOGENERATED_ID = 1;
		const newReserve = await repository.save(sampleReserve);
		expect(newReserve.id).toEqual(NEW_AUTOGENERATED_ID);
		
		expect(await repository.getAll()).toEqual([newReserve]);
	});
	test("returns false if cannot get any reserve", async () => {
		expect(await repository.getAll()).toEqual(false);
	});
});
describe("save method", () => {
    
	test("saves a new reserve if it doesn't have an id", async () => {
		const NEW_AUTOGENERATED_ID = 1;
		const newReserve = await repository.save(sampleReserve);
		expect(newReserve.id).toEqual(NEW_AUTOGENERATED_ID);
	});
	test("saves an edit to a reserve if", async () => {
		const NEW_AUTOGENERATED_ID = 1;
		const newReserve = await repository.save(sampleReserve);
		expect(newReserve.id).toEqual(NEW_AUTOGENERATED_ID);

		newReserve.payed = true;
		const modifiedReserve = await repository.save(newReserve);
		expect(modifiedReserve.payed).toEqual(true);

	});
});
describe("getById method", () => {
	test("returns a reserve", async () => {
		const NEW_AUTOGENERATED_ID = 1;
		const newReserve = await repository.save(sampleReserve);
		expect(newReserve.id).toEqual(NEW_AUTOGENERATED_ID);

		expect(await repository.getById(newReserve.id)).toEqual(newReserve);
	});
	test("throws an error when doesnt found the reserve", async () => {
		await expect(repository.getById(3)).rejects.toThrow(ReserveNotFoundError);
	});
	test("throws an error when receives an invalid id", async () => {
		await expect(repository.getById(undefined)).rejects.toThrow(ReserveIdNotDefinedError);
	});
});
describe("delete method", () => {
	test("deletes an existing reserve", async () => {
		const NEW_AUTOGENERATED_ID = 1;
		const newReserve = await repository.save(sampleReserve);
		expect(newReserve.id).toEqual(NEW_AUTOGENERATED_ID);

		expect(await repository.delete(newReserve.id)).toEqual(newReserve);
		await expect(repository.getById(newReserve.id)).rejects.toThrow(ReserveNotFoundError);

	});
	test("throws an error when couldn't delete the reserve", async () => {
		await expect(repository.delete()).rejects.toThrow(ReserveIdNotDefinedError);
	});
   
});